name: PR Validation

on:
  pull_request:
    branches: [ main ]
  workflow_dispatch:

permissions:
  contents: read
  pull-requests: write

jobs:
  validate-pr:
    runs-on: windows-latest
    name: Validate Pull Request
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup PowerShell
      shell: pwsh
      run: |
        Write-Host "PowerShell Version: $($PSVersionTable.PSVersion)"
        Write-Host "OS: $([System.Environment]::OSVersion.ToString())"

    - name: Validate PowerShell Syntax
      shell: pwsh
      run: |
        Write-Host "=== Validating PowerShell Syntax ===" -ForegroundColor Green
        
        $errors = @()
        $psFiles = Get-ChildItem -Path . -Filter "*.ps1" -Recurse | Where-Object { $_.FullName -notlike "*\.git\*" }
        $psmFiles = Get-ChildItem -Path . -Filter "*.psm1" -Recurse | Where-Object { $_.FullName -notlike "*\.git\*" }
        
        $allFiles = $psFiles + $psmFiles
        
        foreach ($file in $allFiles) {
            Write-Host "Validating: $($file.FullName)" -ForegroundColor Cyan
            
            try {
                $tokens = $null
                $parseErrors = $null
                [System.Management.Automation.Language.Parser]::ParseFile($file.FullName, [ref]$tokens, [ref]$parseErrors)
                
                if ($parseErrors.Count -gt 0) {
                    $errors += "File: $($file.FullName)"
                    foreach ($error in $parseErrors) {
                        $errors += "  Error: $($error.Message) at line $($error.StartLineNumber)"
                    }
                }
                else {
                    Write-Host "  ✓ Syntax OK" -ForegroundColor Green
                }
            }
            catch {
                $errors += "File: $($file.FullName)"
                $errors += "  Exception: $($_.Exception.Message)"
            }
        }
        
        if ($errors.Count -gt 0) {
            Write-Host "=== SYNTAX ERRORS FOUND ===" -ForegroundColor Red
            foreach ($error in $errors) {
                Write-Host $error -ForegroundColor Red
            }
            exit 1
        }
        else {
            Write-Host "=== ALL FILES PASSED SYNTAX VALIDATION ===" -ForegroundColor Green
        }

    - name: Test Core Module Loading
      shell: pwsh
      run: |
        Write-Host "=== Testing Core Module Loading ===" -ForegroundColor Green
        
        # Test loading core modules
        $moduleFiles = Get-ChildItem -Path ".\Modules" -Filter "Common-*.psm1"
        
        foreach ($module in $moduleFiles) {
            Write-Host "Testing module: $($module.Name)" -ForegroundColor Cyan
            try {
                Import-Module $module.FullName -Force
                Write-Host "  ✓ Module loaded successfully" -ForegroundColor Green
                Remove-Module $module.BaseName -Force -ErrorAction SilentlyContinue
            }
            catch {
                Write-Host "  ✗ Failed to load module: $($_.Exception.Message)" -ForegroundColor Red
                exit 1
            }
        }

    - name: Validate Configuration Files
      shell: pwsh
      run: |
        Write-Host "=== Validating Configuration Files ===" -ForegroundColor Green
        
        $configFiles = Get-ChildItem -Path ".\Config" -Filter "*.json" -ErrorAction SilentlyContinue
        
        foreach ($configFile in $configFiles) {
            Write-Host "Validating JSON: $($configFile.Name)" -ForegroundColor Cyan
            try {
                $content = Get-Content $configFile.FullName -Raw
                $json = ConvertFrom-Json $content
                Write-Host "  ✓ Valid JSON" -ForegroundColor Green
            }
            catch {
                Write-Host "  ✗ Invalid JSON: $($_.Exception.Message)" -ForegroundColor Red
                exit 1
            }
        }

    - name: Check for Security Issues
      shell: pwsh
      run: |
        Write-Host "=== Security Validation ===" -ForegroundColor Green
        
        # Check for hardcoded secrets or sensitive information
        $sensitivePatterns = @(
            "password\s*=\s*[`"'].*[`"']",
            "apikey\s*=\s*[`"'].*[`"']",
            "secret\s*=\s*[`"'].*[`"']",
            "token\s*=\s*[`"'].*[`"']"
        )
        
        $issues = @()
        $allFiles = Get-ChildItem -Path . -Include "*.ps1", "*.psm1", "*.json" -Recurse | Where-Object { $_.FullName -notlike "*\.git\*" }
        
        foreach ($file in $allFiles) {
            $content = Get-Content $file.FullName -Raw
            foreach ($pattern in $sensitivePatterns) {
                if ($content -match $pattern) {
                    $issues += "Potential sensitive data found in: $($file.FullName)"
                }
            }
        }
        
        if ($issues.Count -gt 0) {
            Write-Host "=== SECURITY ISSUES FOUND ===" -ForegroundColor Yellow
            foreach ($issue in $issues) {
                Write-Host $issue -ForegroundColor Yellow
            }
            Write-Host "Please review these findings manually." -ForegroundColor Yellow
        }
        else {
            Write-Host "✓ No obvious security issues detected" -ForegroundColor Green
        }

    - name: Comment PR Results
      uses: actions/github-script@v7
      if: always()
      with:
        script: |
          const { context } = github;
          const prNumber = context.payload.pull_request?.number;
          
          if (prNumber) {
            const body = `
            ## 🔍 PR Validation Results
            
            ✅ **PowerShell Syntax**: All files passed syntax validation
            ✅ **Module Loading**: Core modules load successfully  
            ✅ **Configuration**: JSON files are valid
            ✅ **Security**: Basic security checks completed
            
            > This PR has been automatically validated and is ready for code owner review by @aiturralde
            
            ---
            *Automated validation completed on ${new Date().toISOString()}*
            `;
            
            await github.rest.issues.createComment({
              issue_number: prNumber,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });
          }
